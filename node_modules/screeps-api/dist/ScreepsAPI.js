'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var WebSocket = _interopDefault(require('ws'));
var URL = require('url');
var URL__default = _interopDefault(URL);
var events = require('events');
var Debug = _interopDefault(require('debug'));
var zlib = _interopDefault(require('zlib'));
var axios = _interopDefault(require('axios'));
var util = _interopDefault(require('util'));
var fs = _interopDefault(require('fs'));
var YAML = _interopDefault(require('yamljs'));
var path = _interopDefault(require('path'));

const debug = Debug('screepsapi:socket');

const DEFAULTS$1 = {
  reconnect: true,
  resubscribe: true,
  keepAlive: true,
  maxRetries: 10,
  maxRetryDelay: 60 * 1000 // in milli-seconds
};

class Socket extends events.EventEmitter {
  constructor (ScreepsAPI) {
    super();
    this.api = ScreepsAPI;
    this.opts = Object.assign({}, DEFAULTS$1);
    this.on('error', () => {}); // catch to prevent unhandled-exception errors
    this.reset();
    this.on('auth', ev => {
      if (ev.data.status === 'ok') {
        while (this.__queue.length) {
          this.emit(this.__queue.shift());
        }
        clearInterval(this.keepAliveInter);
        if (this.opts.keepAlive) {
          this.keepAliveInter = setInterval(() => this.ws && this.ws.ping(1), 10000);
        }
      }
    });
  }

  reset () {
    this.authed = false;
    this.connected = false;
    this.reconnecting = false;
    clearInterval(this.keepAliveInter);
    this.keepAliveInter = 0;
    this.__queue = []; // pending messages  (to send once authenticated)
    this.__subQueue = []; // pending subscriptions (to request once authenticated)
    this.__subs = {}; // number of callbacks for each subscription
  }

  async connect (opts = {}) {
    Object.assign(this.opts, opts);
    if (!this.api.token) {
      throw new Error('No token! Call api.auth() before connecting the socket!')
    }
    return new Promise((resolve, reject) => {
      const baseURL = this.api.opts.url.replace('http', 'ws');
      const wsurl = new URL.URL('socket/websocket', baseURL);
      this.ws = new WebSocket(wsurl);
      this.ws.on('open', () => {
        this.connected = true;
        this.reconnecting = false;
        if (this.opts.resubscribe) {
          this.__subQueue.push(...Object.keys(this.__subs));
        }
        debug('connected');
        this.emit('connected');
        resolve(this.auth(this.api.token));
      });
      this.ws.on('close', () => {
        clearInterval(this.keepAliveInter);
        this.authed = false;
        this.connected = false;
        debug('disconnected');
        this.emit('disconnected');
        if (this.opts.reconnect) {
          this.reconnect().catch(() => { /* error emitted in reconnect() */ });
        }
      });
      this.ws.on('error', (err) => {
        this.ws.terminate();
        this.emit('error', err);
        debug(`error ${err}`);
        if (!this.connected) {
          reject(err);
        }
      });
      this.ws.on('unexpected-response', (req, res) => {
        const err = new Error(`WS Unexpected Response: ${res.statusCode} ${res.statusMessage}`);
        this.emit('error', err);
        reject(err);
      });
      this.ws.on('message', (data) => this.handleMessage(data));
    })
  }

  async reconnect () {
    Object.keys(this.__subs).forEach(sub => this.subscribe(sub));
    this.reconnecting = true;
    let retries = 0;
    let retry;
    do {
      let time = Math.pow(2, retries) * 100;
      if (time > this.opts.maxRetryDelay) time = this.opts.maxRetryDelay;
      await this.sleep(time);
      if (!this.reconnecting) return // reset() called in-between
      try {
        await this.connect();
        retry = false;
      } catch (err) {
        retry = true;
      }
      retries++;
      debug(`reconnect ${retries}/${this.opts.maxRetries}`);
    } while (retry && retries < this.opts.maxRetries)
    if (retry) {
      const err = new Error(`Reconnection failed after ${this.opts.maxRetries} retries`);
      this.reconnecting = false;
      debug('reconnect failed');
      this.emit('error', err);
      throw err
    }
  }

  disconnect () {
    debug('disconnect');
    clearInterval(this.keepAliveInter);
    this.ws.removeAllListeners(); // remove listeners first or we may trigger reconnection & Co.
    this.ws.terminate();
    this.reset();
    this.emit('disconnected');
  }

  sleep (time) {
    return new Promise((resolve, reject) => {
      setTimeout(resolve, time);
    })
  }

  handleMessage (msg) {
    msg = msg.data || msg; // Handle ws/browser difference
    if (msg.slice(0, 3) === 'gz:') { msg = this.api.inflate(msg); }
    debug(`message ${msg}`);
    if (msg[0] === '[') {
      msg = JSON.parse(msg);
      let [, type, id, channel] = msg[0].match(/^(.+):(.+?)(?:\/(.+))?$/);
      channel = channel || type;
      const event = { channel, id, type, data: msg[1] };
      this.emit(msg[0], event);
      this.emit(event.channel, event);
      this.emit('message', event);
    } else {
      const [channel, ...data] = msg.split(' ');
      const event = { type: 'server', channel, data };
      if (channel === 'auth') { event.data = { status: data[0], token: data[1] }; }
      if (['protocol', 'time', 'package'].includes(channel)) { event.data = { [channel]: data[0] }; }
      this.emit(channel, event);
      this.emit('message', event);
    }
  }

  async gzip (bool) {
    this.send(`gzip ${bool ? 'on' : 'off'}`);
  }

  async send (data) {
    if (!this.connected) {
      this.__queue.push(data);
    } else {
      this.ws.send(data);
    }
  }

  auth (token) {
    return new Promise((resolve, reject) => {
      this.send(`auth ${token}`);
      this.once('auth', (ev) => {
        const { data } = ev;
        if (data.status === 'ok') {
          this.authed = true;
          this.emit('token', data.token);
          this.emit('authed');
          while (this.__subQueue.length) {
            this.send(this.__subQueue.shift());
          }
          resolve();
        } else {
          reject(new Error('socket auth failed'));
        }
      });
    })
  }

  async subscribe (path$$1, cb) {
    if (!path$$1) return
    const userID = await this.api.userID();
    if (!path$$1.match(/^(\w+):(.+?)$/)) { path$$1 = `user:${userID}/${path$$1}`; }
    if (this.authed) {
      this.send(`subscribe ${path$$1}`);
    } else {
      this.__subQueue.push(`subscribe ${path$$1}`);
    }
    this.emit('subscribe', path$$1);
    this.__subs[path$$1] = this.__subs[path$$1] || 0;
    this.__subs[path$$1]++;
    if (cb) this.on(path$$1, cb);
  }

  async unsubscribe (path$$1) {
    if (!path$$1) return
    const userID = await this.api.userID();
    if (!path$$1.match(/^(\w+):(.+?)$/)) { path$$1 = `user:${userID}/${path$$1}`; }
    this.send(`unsubscribe ${path$$1}`);
    this.emit('unsubscribe', path$$1);
    if (this.__subs[path$$1]) this.__subs[path$$1]--;
  }
}

const debugHttp = Debug('screepsapi:http');
const debugRateLimit = Debug('screepsapi:ratelimit');

const { format } = URL__default;

const gunzipAsync = util.promisify(zlib.gunzip);
const inflateAsync = util.promisify(zlib.inflate);

const DEFAULT_SHARD = 'shard0';
const OFFICIAL_HISTORY_INTERVAL = 100;
const PRIVATE_HISTORY_INTERVAL = 20;

const sleep = ms => new Promise(resolve => setInterval(resolve, ms));

class RawAPI extends events.EventEmitter {
  constructor (opts = {}) {
    super();
    this.setServer(opts);
    const self = this;
    this.raw = {
      version () {
        return self.req('GET', '/api/version')
      },
      authmod () {
        if (self.isOfficialServer()) {
          return Promise.resolve({ name: 'official' })
        }
        return self.req('GET', '/api/authmod')
      },
      history (room, tick, shard = DEFAULT_SHARD) {
        if (self.isOfficialServer()) {
          tick -= tick % OFFICIAL_HISTORY_INTERVAL;
          return self.req('GET', `/room-history/${shard}/${room}/${tick}.json`)
        } else {
          tick -= tick % PRIVATE_HISTORY_INTERVAL;
          return self.req('GET', '/room-history', { room, time: tick })
        }
      },
      servers: {
        list () {
          return self.req('POST', '/api/servers.list', {})
        }
      },
      auth: {
        signin (email, password) {
          return self.req('POST', '/api/auth/signin', { email, password })
        },
        steamTicket (ticket, useNativeAuth = false) {
          return self.req('POST', '/api/auth/steam-ticket', { ticket, useNativeAuth })
        },
        me () {
          return self.req('GET', '/api/auth/me')
        },
        queryToken (token) {
          return self.req('GET', '/api/auth/query-token', { token })
        }
      },
      register: {
        checkEmail (email) {
          return self.req('GET', '/api/register/check-email', { email })
        },
        checkUsername (username) {
          return self.req('GET', '/api/register/check-username', { username })
        },
        setUsername (username) {
          return self.req('POST', '/api/register/set-username', { username })
        },
        submit (username, email, password, modules) {
          return self.req('POST', '/api/register/submit', { username, email, password, modules })
        }
      },
      userMessages: {
        list (respondent) {
          return self.req('GET', '/api/user/messages/list', { respondent })
        },
        index () {
          return self.req('GET', '/api/user/messages/index')
        },
        unreadCount () {
          return self.req('GET', '/api/user/messages/unread-count')
        },
        send (respondent, text) {
          return self.req('POST', '/api/user/messages/send', { respondent, text })
        },
        markRead (id) {
          return self.req('POST', '/api/user/messages/mark-read', { id })
        }
      },
      game: {
        mapStats (rooms, statName, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/map-stats', { rooms, statName, shard })
        },
        genUniqueObjectName (type, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/gen-unique-object-name', { type, shard })
        },
        checkUniqueObjectName (type, name, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/check-unique-object-name', { type, name, shard })
        },
        placeSpawn (room, x, y, name, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/place-spawn', { name, room, x, y, shard })
        },
        createFlag (room, x, y, name, color = 1, secondaryColor = 1, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/create-flag', { name, room, x, y, color, secondaryColor, shard })
        },
        genUniqueFlagName (shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/gen-unique-flag-name', { shard })
        },
        checkUniqueFlagName (name, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/check-unique-flag-name', { name, shard })
        },
        changeFlagColor (color = 1, secondaryColor = 1, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/change-flag-color', { color, secondaryColor, shard })
        },
        removeFlag (room, name, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/remove-flag', { name, room, shard })
        },
        addObjectIntent (room, name, intent, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/add-object-intent', { room, name, intent, shard })
        },
        createConstruction (room, x, y, structureType, name, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/create-construction', { room, x, y, structureType, name, shard })
        },
        setNotifyWhenAttacked (_id, enabled = true, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/set-notify-when-attacked', { _id, enabled, shard })
        },
        createInvader (room, x, y, size, type, boosted = false, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/create-invader', { room, x, y, size, type, boosted, shard })
        },
        removeInvader (_id, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/game/remove-invader', { _id, shard })
        },
        time (shard = DEFAULT_SHARD) {
          return self.req('GET', '/api/game/time', { shard })
        },
        worldSize (shard = DEFAULT_SHARD) {
          return self.req('GET', '/api/game/world-size', { shard })
        },
        roomDecorations (room, shard = DEFAULT_SHARD) {
          return self.req('GET', '/api/game/room-decorations', { room, shard })
        },
        roomObjects (room, shard = DEFAULT_SHARD) {
          return self.req('GET', '/api/game/room-objects', { room, shard })
        },
        roomTerrain (room, encoded = 1, shard = DEFAULT_SHARD) {
          return self.req('GET', '/api/game/room-terrain', { room, encoded, shard })
        },
        roomStatus (room, shard = DEFAULT_SHARD) {
          return self.req('GET', '/api/game/room-status', { room, shard })
        },
        roomOverview (room, interval = 8, shard = DEFAULT_SHARD) {
          return self.req('GET', '/api/game/room-overview', { room, interval, shard })
        },
        market: {
          ordersIndex (shard = DEFAULT_SHARD) {
            return self.req('GET', '/api/game/market/orders-index', { shard })
          },
          myOrders () {
            return self.req('GET', '/api/game/market/my-orders').then(self.mapToShard)
          },
          orders (resourceType, shard = DEFAULT_SHARD) {
            return self.req('GET', '/api/game/market/orders', { resourceType, shard })
          },
          stats (resourceType, shard = DEFAULT_SHARD) {
            return self.req('GET', '/api/game/market/stats', { resourceType, shard })
          }
        },
        shards: {
          info () {
            return self.req('GET', '/api/game/shards/info')
          }
        }
      },
      leaderboard: {
        list (limit = 10, mode = 'world', offset = 0, season) {
          if (mode !== 'world' && mode !== 'power') throw new Error('incorrect mode parameter')
          if (!season) season = self.currentSeason();
          return self.req('GET', '/api/leaderboard/list', { limit, mode, offset, season })
        },
        find (username, mode = 'world', season = '') {
          return self.req('GET', '/api/leaderboard/find', { season, mode, username })
        },
        seasons () {
          return self.req('GET', '/api/leaderboard/seasons')
        }
      },
      user: {
        badge (badge) {
          return self.req('POST', '/api/user/badge', { badge })
        },
        respawn () {
          return self.req('POST', '/api/user/respawn')
        },
        setActiveBranch (branch, activeName) {
          return self.req('POST', '/api/user/set-active-branch', { branch, activeName })
        },
        cloneBranch (branch, newName, defaultModules) {
          return self.req('POST', '/api/user/clone-branch', { branch, newName, defaultModules })
        },
        deleteBranch (branch) {
          return self.req('POST', '/api/user/delete-branch', { branch })
        },
        notifyPrefs (prefs) {
          // disabled,disabledOnMessages,sendOnline,interval,errorsInterval
          return self.req('POST', '/api/user/notify-prefs', prefs)
        },
        tutorialDone () {
          return self.req('POST', '/api/user/tutorial-done')
        },
        email (email) {
          return self.req('POST', '/api/user/email', { email })
        },
        worldStartRoom (shard) {
          return self.req('GET', '/api/user/world-start-room', { shard })
        },
        worldStatus () {
          return self.req('GET', '/api/user/world-status')
        },
        branches () {
          return self.req('GET', '/api/user/branches')
        },
        code: {
          get (branch) {
            return self.req('GET', '/api/user/code', { branch })
          },
          set (branch, modules, _hash) {
            if (!_hash) _hash = Date.now();
            return self.req('POST', '/api/user/code', { branch, modules, _hash })
          }
        },
        decorations: {
          inventory () {
            return self.req('GET', '/api/user/decorations/inventory')
          },
          themes () {
            return self.req('GET', '/api/user/decorations/inventory')
          },
          convert (decorations) {
            return self.req('POST', '/api/user/decorations/convert', { decorations }) // decorations is a string array of ids
          },
          pixelize (count, theme = '') {
            return self.req('POST', '/api/user/decorations/pixelize', { count, theme })
          },
          activate (_id, active) {
            return self.req('POST', '/api/user/decorations/activate', { _id, active })
          },
          deactivate (decorations) {
            return self.req('POST', '/api/user/decorations/deactivate', { decorations }) // decorations is a string array of ids
          }
        },
        respawnProhibitedRooms () {
          return self.req('GET', '/api/user/respawn-prohibited-rooms')
        },
        memory: {
          get (path$$1, shard = DEFAULT_SHARD) {
            return self.req('GET', '/api/user/memory', { path: path$$1, shard })
          },
          set (path$$1, value, shard = DEFAULT_SHARD) {
            return self.req('POST', '/api/user/memory', { path: path$$1, value, shard })
          },
          segment: {
            get (segment, shard = DEFAULT_SHARD) {
              return self.req('GET', '/api/user/memory-segment', { segment, shard })
            },
            set (segment, data, shard = DEFAULT_SHARD) {
              return self.req('POST', '/api/user/memory-segment', { segment, data, shard })
            }
          }
        },
        find (username) {
          return self.req('GET', '/api/user/find', { username })
        },
        findById (id) {
          return self.req('GET', '/api/user/find', { id })
        },
        stats (interval) {
          return self.req('GET', '/api/user/stats', { interval })
        },
        rooms (id) {
          return self.req('GET', '/api/user/rooms', { id }).then(self.mapToShard)
        },
        overview (interval, statName) {
          return self.req('GET', '/api/user/overview', { interval, statName })
        },
        moneyHistory (page = 0) {
          return self.req('GET', '/api/user/money-history', { page })
        },
        console (expression, shard = DEFAULT_SHARD) {
          return self.req('POST', '/api/user/console', { expression, shard })
        },
        name () {
          return self.req('GET', '/api/user/name')
        }
      },
      experimental: {
        pvp (interval = 100) {
          return self.req('GET', '/api/experimental/pvp', { interval }).then(self.mapToShard)
        },
        nukes () {
          return self.req('GET', '/api/experimental/nukes').then(self.mapToShard)
        }
      },
      warpath: {
        battles (interval = 100) {
          return self.req('GET', '/api/warpath/battles', { interval })
        }
      },
      scoreboard: {
        list (limit = 20, offset = 0) {
          return self.req('GET', '/api/scoreboard/list', { limit, offset })
        }
      }
    };
  }

  currentSeason () {
    const now = new Date();
    const year = now.getFullYear();
    let month = (now.getUTCMonth() + 1).toString();
    if (month.length === 1) month = `0${month}`;
    return `${year}-${month}`
  }

  isOfficialServer () {
    return this.opts.url.match(/screeps\.com/) !== null
  }

  mapToShard (res) {
    if (!res.shards) {
      res.shards = {
        privSrv: res.list || res.rooms
      };
    }
    return res
  }

  setServer (opts) {
    if (!this.opts) {
      this.opts = {};
    }
    Object.assign(this.opts, opts);
    if (opts.path && !opts.pathname) {
      this.opts.pathname = this.opts.path;
    }
    if (!opts.url) {
      this.opts.url = format(this.opts);
      if (!this.opts.url.endsWith('/')) this.opts.url += '/';
    }
    if (opts.token) {
      this.token = opts.token;
    }
    this.http = axios.create({
      baseURL: this.opts.url
    });
  }

  async auth (email, password, opts = {}) {
    this.setServer(opts);
    if (email && password) {
      Object.assign(this.opts, { email, password });
    }
    const res = await this.raw.auth.signin(this.opts.email, this.opts.password);
    this.emit('token', res.token);
    this.emit('auth');
    this.__authed = true;
    return res
  }

  async req (method, path$$1, body = {}) {
    const opts = {
      method,
      url: path$$1,
      headers: {}
    };
    debugHttp(`${method} ${path$$1} ${JSON.stringify(body)}`);
    if (this.token) {
      Object.assign(opts.headers, {
        'X-Token': this.token,
        'X-Username': this.token
      });
    }
    if (method === 'GET') {
      opts.params = body;
    } else {
      opts.data = body;
    }
    try {
      const res = await this.http(opts);
      const token = res.headers['x-token'];
      if (token) {
        this.emit('token', token);
      }
      const rateLimit = this.buildRateLimit(method, path$$1, res);
      this.emit('rateLimit', rateLimit);
      debugRateLimit(`${method} ${path$$1} ${rateLimit.remaining}/${rateLimit.limit} ${rateLimit.toReset}s`);
      if (typeof res.data.data === 'string' && res.data.data.slice(0, 3) === 'gz:') {
        res.data.data = await this.gz(res.data.data);
      }
      this.emit('response', res);
      return res.data
    } catch (err) {
      const res = err.response || {};
      const rateLimit = this.buildRateLimit(method, path$$1, res);
      this.emit('rateLimit', rateLimit);
      debugRateLimit(`${method} ${path$$1} ${rateLimit.remaining}/${rateLimit.limit} ${rateLimit.toReset}s`);
      if (res.status === 401) {
        if (this.__authed && this.opts.email && this.opts.password) {
          this.__authed = false;
          await this.auth(this.opts.email, this.opts.password);
          return this.req(method, path$$1, body)
        } else {
          throw new Error('Not Authorized')
        }
      }
      if (res.status === 429 && !res.headers['x-ratelimit-limit'] && this.opts.experimentalRetry429) {
        await sleep(Math.floor(Math.random() * 500) + 200);
        return this.req(method, path$$1, body)
      }
      throw new Error(res.data)
    }
  }

  async gz (data) {
    const buf = Buffer.from(data.slice(3), 'base64');
    const ret = await gunzipAsync(buf);
    return JSON.parse(ret.toString())
  }

  async inflate (data) { // es
    const buf = Buffer.from(data.slice(3), 'base64');
    const ret = await inflateAsync(buf);
    return JSON.parse(ret.toString())
  }

  buildRateLimit (method, path$$1, res) {
    const {
      headers: {
        'x-ratelimit-limit': limit,
        'x-ratelimit-remaining': remaining,
        'x-ratelimit-reset': reset
      } = {}
    } = res;
    return {
      method,
      path: path$$1,
      limit: +limit,
      remaining: +remaining,
      reset: +reset,
      toReset: reset - Math.floor(Date.now() / 1000)
    }
  }
}

const readFileAsync = util.promisify(fs.readFile);

class ConfigManager {
  async refresh () {
    this._config = null;
    await this.getConfig();
  }

  async getServers () {
    const conf = await this.getConfig();
    return Object.keys(conf.servers)
  }

  async getConfig () {
    if (this._config) {
      return this._config
    }
    const paths = [];
    if (process.env.SCREEPS_CONFIG) {
      paths.push(process.env.SCREEPS_CONFIG);
    }
    const dirs = [__dirname, ''];
    for (const dir of dirs) {
      paths.push(path.join(dir, '.screeps.yaml'));
      paths.push(path.join(dir, '.screeps.yml'));
    }
    if (process.platform === 'win32') {
      paths.push(path.join(process.env.APPDATA, 'screeps/config.yaml'));
      paths.push(path.join(process.env.APPDATA, 'screeps/config.yml'));
    } else {
      if (process.env.XDG_CONFIG_PATH) {
        paths.push(
          path.join(process.env.XDG_CONFIG_HOME, 'screeps/config.yaml')
        );
        paths.push(
          path.join(process.env.XDG_CONFIG_HOME, 'screeps/config.yml')
        );
      }
      if (process.env.HOME) {
        paths.push(path.join(process.env.HOME, '.config/screeps/config.yaml'));
        paths.push(path.join(process.env.HOME, '.config/screeps/config.yml'));
        paths.push(path.join(process.env.HOME, '.screeps.yaml'));
        paths.push(path.join(process.env.HOME, '.screeps.yml'));
      }
    }
    for (const path$$1 of paths) {
      const data = await this.loadConfig(path$$1);
      if (data) {
        if (!data.servers) {
          throw new Error(
            `Invalid config: 'servers' object does not exist in '${path$$1}'`
          )
        }
        this._config = data;
        this.path = path$$1;
        return data
      }
    }
    return null
  }

  async loadConfig (file) {
    try {
      const contents = await readFileAsync(file, 'utf8');
      return YAML.parse(contents)
    } catch (e) {
      if (e.code === 'ENOENT') {
        return false
      } else {
        throw e
      }
    }
  }
}

const DEFAULTS = {
  protocol: 'https',
  hostname: 'screeps.com',
  port: 443,
  path: '/'
};

const configManager = new ConfigManager();

class ScreepsAPI extends RawAPI {
  static async fromConfig (server = 'main', config = false, opts = {}) {
    const data = await configManager.getConfig();

    if (data) {
      if (!data.servers[server]) {
        throw new Error(`Server '${server}' does not exist in '${configManager.path}'`)
      }

      const conf = data.servers[server];
      if (conf.ptr) conf.path = '/ptr';
      if (conf.season) conf.path = '/season';
      const api = new ScreepsAPI(
        Object.assign(
          {
            hostname: conf.host,
            port: conf.port,
            protocol: conf.secure ? 'https' : 'http',
            token: conf.token,
            path: conf.path || '/'
          },
          opts
        )
      );

      api.appConfig = (data.configs && data.configs[config]) || {};

      if (!conf.token && conf.username && conf.password) {
        await api.auth(conf.username, conf.password);
      }

      return api
    }

    throw new Error('No valid config found')
  }

  constructor (opts) {
    opts = Object.assign({}, DEFAULTS, opts);
    super(opts);
    this.on('token', token => {
      this.token = token;
      this.raw.token = token;
    });
    const defaultLimit = (limit, period) => ({
      limit,
      period,
      remaining: limit,
      reset: 0,
      toReset: 0
    });
    this.rateLimits = {
      global: defaultLimit(120, 'minute'),
      GET: {
        '/api/game/room-terrain': defaultLimit(360, 'hour'),
        '/api/user/code': defaultLimit(60, 'hour'),
        '/api/user/memory': defaultLimit(1440, 'day'),
        '/api/user/memory-segment': defaultLimit(360, 'hour'),
        '/api/game/market/orders-index': defaultLimit(60, 'hour'),
        '/api/game/market/orders': defaultLimit(60, 'hour'),
        '/api/game/market/my-orders': defaultLimit(60, 'hour'),
        '/api/game/market/stats': defaultLimit(60, 'hour'),
        '/api/game/user/money-history': defaultLimit(60, 'hour')
      },
      POST: {
        '/api/user/console': defaultLimit(360, 'hour'),
        '/api/game/map-stats': defaultLimit(60, 'hour'),
        '/api/user/code': defaultLimit(240, 'day'),
        '/api/user/set-active-branch': defaultLimit(240, 'day'),
        '/api/user/memory': defaultLimit(240, 'day'),
        '/api/user/memory-segment': defaultLimit(60, 'hour')
      }
    };
    this.on('rateLimit', limits => {
      const rate =
        this.rateLimits[limits.method][limits.path] || this.rateLimits.global;
      const copy = Object.assign({}, limits);
      delete copy.path;
      delete copy.method;
      Object.assign(rate, copy);
    });
    this.socket = new Socket(this);
  }

  getRateLimit (method, path$$1) {
    return this.rateLimits[method][path$$1] || this.rateLimits.global
  }

  get rateLimitResetUrl () {
    return `https://screeps.com/a/#!/account/auth-tokens/noratelimit?token=${this.token.slice(
      0,
      8
    )}`
  }

  async me () {
    if (this._user) return this._user
    const tokenInfo = await this.tokenInfo();
    if (tokenInfo.full) {
      this._user = await this.raw.auth.me();
    } else {
      const { username } = await this.raw.user.name();
      const { user } = await this.raw.user.find(username);
      this._user = user;
    }
    return this._user
  }

  async tokenInfo () {
    if (this._tokenInfo) {
      return this._tokenInfo
    }
    if (this.opts.token) {
      const { token } = await this.raw.auth.queryToken(this.token);
      this._tokenInfo = token;
    } else {
      this._tokenInfo = { full: true };
    }
    return this._tokenInfo
  }

  async userID () {
    const user = await this.me();
    return user._id
  }

  get history () {
    return this.raw.history
  }

  get authmod () {
    return this.raw.authmod
  }

  get version () {
    return this.raw.version
  }

  get time () {
    return this.raw.game.time
  }

  get leaderboard () {
    return this.raw.leaderboard
  }

  get market () {
    return this.raw.game.market
  }

  get registerUser () {
    return this.raw.register.submit
  }

  get code () {
    return this.raw.user.code
  }

  get memory () {
    return this.raw.user.memory
  }

  get segment () {
    return this.raw.user.memory.segment
  }

  get console () {
    return this.raw.user.console
  }
}

exports.ScreepsAPI = ScreepsAPI;
